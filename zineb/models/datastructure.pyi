from typing import Any, Callable, Generic, List, Optional, Type, TypeVar, Union, Dict, OrderedDict
Order
from utils.containers import SmartDict
from zineb.http.responses import HTMLResponse
from zineb.models.fields import Field
from zineb.models.datastructure import ModelOptions
from zineb.models.functions import Add, Divide, Multiply, Substract, When

T = TypeVar('T', covariant=True)



class ModelOptions:
    # constraints: List = ...
    # field_names: List[str] = ...
    # fields_map: OrderedDict[str, Field]
    # model_name: str = ...
    # ordering: List[str] = ...
    # parents: set = ...
    # verbose_name: str = ...
    def __repr__(self) -> str: ...
    def get_field(self, name: str) -> Field: ...


class Base(type):
    def __new__(cls: Type, name: str, bases: tuple, attrs: dict) -> Type[Model]: ...
    
        
class Model(metaclass=Base):
    html_document: type = ...
    response: HTMLResponse = ...
    _data_container: SmartDict = ...
    _meta: ModelOptions = ...
    def __init__(self, html_document = ..., response: HTMLResponse = ...): ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __getitem__(self) -> str: ...
    def _get_field_by_name(self, field_name: str) -> Field: ...
    def add_calculated_value(self, name: str, value: Any, *funcs: Optional[Union[Add, Divide, Substract, Multiply]]) -> None: ...
    def add_case(self, value: Any, case: When) -> None: ...
    def add_using_expression(self, name: str, tag: str, attrs: Optional[dict] = ...) -> None: ...
    def add_values(self, **attrs) -> None: ...
    def add_value(self, name: str, value: Any) -> None: ...
    def full_clean(self, **kwargs) -> None: ...
    def clean(self, dataframe: List, **kwargs) -> None: ...
    def save(self, commit: Optional[bool] = ..., filename: Optional[str] = ..., **kwargs) -> Union[None, Union[list, dict]]: ...
